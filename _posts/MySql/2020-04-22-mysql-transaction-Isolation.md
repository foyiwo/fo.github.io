---
layout: post
title: MySQL · InnoDB · 事务原理详解 · 隔离性
description: ""
modified: 2020-06-27
tags: [高级MySql]

---

本篇述说**事务的隔离性**实现原理

---

### 背景概述
数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。

事务拥有四个重要的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），人们习惯称之为 ACID 特性。下面我逐一对其进行解释。

- 原子性（Atomicity）:事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。例如，如果一个事务需要新增 100 条记录，但是在新增了 10 条记录之后就失败了，那么数据库将回滚对这 10 条新增的记录。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。

- 一致性（Consistency）:指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。

- **隔离性（Isolation）**:要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务不可见。 也可以理解为多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。例如一个用户在更新自己的个人信息的同时，是不能看到系统管理员也在更新该用户的个人信息（此时更新事务还未提交）。（注：MySQL 通过锁机制来保证事务的隔离性。）

- 持久性（Durability）:事务一旦提交，则其结果就是永久性的。即使发生宕机的故障，数据库也能将数据恢复，也就是说事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。这只是从事务本身的角度来保证，排除 RDBMS（关系型数据库管理系统，例如 Oracle、MySQL 等）本身发生的故障。（注：MySQL 使用 redo log 来保证事务的持久性。）


任何技术的出现，都是为了解决某个问题，那么，事务的隔离性是为了解决什么问题呢？

现在我们来假定一种场景：

现在有一个存储着商城积分的MySQL数据库(假设没有事务的控制)，现发现同一时刻数据库有2条线程要对某个人(价格:ID=1，期初积分:100)的积分进行数据更新，更新流程如下：

1. 事务A(在ID=1积分基础上加300)开始，同时事务B(在ID=1积分基础上加400)开始
2. 事务A先查询ID=1的积分信息，此时得到积分=100。
3. 接着事务A在积分100的基础上加300，并更新回去，所以这时数据库里积分=400
4. 这时事务B抢占了CPU，它查询ID=1的积分信息，由于第3步的更新，此时得到积分=400。
5. 紧急着事务A又抢占了CPU，这时事务A一检查，发现刚才积分所加的积分不合规，于是回滚刚刚的更新操作，于是这时数据库里的积分=100
6. 然后，事务A提交。
7. 这时又轮到了事务B，事务B刚查询到的积分=400，在此基础上，加400积分并更新。
8. 最后事务B提交
9. 最后，数据库里的积分=800

发现了没有，一波操作之后，积分出现异常了，其根本原因是事务B读到了事务A还未提交的数据，而这种异常现象，在数据库里称为：**脏读**

以此为砖，引出数据库里因高并发特性下，可能会出现的几个问题如下：

- **脏读**：指当一个事务正在访问数据，并且对该数据进行了修改，但该事务还未提交，与此同时，另外一个事务也访问了该数据，并使用了该数据的现象。
- **不可重复读**：指在一个事务内，前后多次读取同一数据，但由于其他事务干扰，导致前后读取同一数据，但前后却不一致的现象。比如,事务A起先读取了ID=1的数据信息到内存，而后事务B读取ID=1的数据，并将其数据更新后提交事务，然后事务A又再次读取ID=1的数据，这时就会发现对于同一事务内，前后读取到同一数据的竟不一致。
- **幻读**：指在一个事务内，前后多次访问一个区间内的数据，但由于其他事务干扰，导致前后读取到的区间数据数量不一样的现象。比如，事务A起先查询了age=18的数据总共10行，并进行数据更新，在事务A未提交前，事务B这时抢占了CPU，而事务B插入了一条age=18的数据，并提交，这时事务A再次查询age=18，就会发现查出了11条数据，并且其中还有一条是未更新过的，就像你用了update语句更新数据，然后更新完之后，你发现少了一条没更新到，你说奇怪不奇怪，就称为幻读。


遇到问题，自然是要解决的，而上面问题的根本原因就是事务之间(未提交之前)的数据是可以互相被访问到的，也就是说，没有彼此隔离开来。
为解决以上问题，数据库专家们，为此提出了事务的**隔离性**概念(隔离的意思就是隔离各事务数据的相互干扰)，并给隔离性分了等级，每个等级会解决对应的问题，展示如下：

- **READ UNCOMMITTED（读未提交）**：该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。大部分业务场景都不允许脏读出现，但是此隔离级别下数据库的并发是最好的。
- **READ COMMITTED（读提交）**：该隔离级别下，一个事务可以只能读取到另一个已提交的事务(读取不到未提交的数据，解决了脏读问题）,但多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。
- **REPEATABLE READ（可重复读）**：该隔离级别是MySQL默认的隔离级别,在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的 InnoDB 引擎可以通过 next-key locks 机制来避免幻读。

- **SERIALIZABLE（序列化）**:在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。


以上便是专家们定义的隔离级别，越往下，隔离性和安全级别越高，但并发也随之下降。

为了更好的理解并记住抽象的隔离性，下面以MySQL的InnoDB引擎来说明，它是怎么实现各个隔离级别的。

首先，默认情况下，InnoDB的隔离级别是：**REPEATABLE READ（可重复读）**,同时，通过**next-key locks机制**解决了幻读的问题

### 第一个问题：脏读的解决

在MySQL里，InnoDB使用锁来解决了脏读问题，更具体一点，是行级锁。

锁是一个大话题，为此，我另开文章描述。

### MVCC















